--- File: ./app/Main.hs ---
module Main where

import Lib

main :: IO ()
main = goodbot

--- File: ./src/Calculator.hs ---
{-# LANGUAGE OverloadedStrings #-}

module Calculator
    ( CalcExpr
    , eval
    , calcExpr
    ) where

import           Commands                       ( Parser
                                                , int
                                                , num
                                                )
import           Control.Applicative            ( (<|>) )
import           Data.Fixed                     ( mod' )
import           Data.Functor                   ( ($>)
                                                , (<&>)
                                                )
import           Math.Gamma                     ( gamma )
import           System.Random                  ( randomRIO )
import qualified Text.Megaparsec               as P
import           Text.Megaparsec                ( (<?>) )
import qualified Text.Megaparsec.Char          as P

data BinaryOp
    = Plus
    | Minus
    | Times
    | Divide
    | Exponent
    | Mod
    deriving (Show, Eq)

data PrefixOp
    = Sqrt
    | Cbrt
    | Log
    | Ln
    | Sin
    | Cos
    | Tan
    | Sinh
    | Cosh
    | Tanh
    | Abs
    | Round
    | Floor
    | Ceil
    | Degrees
    | Radians
    | Neg
    | Fact
    | RandFloat
    | RandInt
    | Rand
    deriving (Show, Eq)

data SuffixOp
    = Percent
    | Factorial
    | DoubleFactorial
    deriving (Show, Eq)

data CalcExpr
    = CalcBinary CalcExpr BinaryOp CalcExpr
    | CalcPrefix PrefixOp CalcExpr
    | CalcSuffix CalcExpr SuffixOp
    | CalcVal Double
    deriving (Show, Eq)

precedence :: BinaryOp -> Int
precedence Plus     = 2
precedence Minus    = 2
precedence Times    = 3
precedence Divide   = 3
precedence Mod      = 3
precedence Exponent = 8

calcExpr :: Parser CalcExpr
calcExpr = P.space *> calcExpr' Nothing <* P.eof

calcExpr' :: Maybe CalcExpr -> Parser CalcExpr

calcExpr' Nothing = do
    lhs <- single
    (calcExpr' (Just lhs) <|> pure lhs) <* P.space

calcExpr' (Just lhs) = (binaryExpr lhs <|> pure lhs) <* P.space

valExpr :: Parser CalcExpr
valExpr = do
    v      <- value <|> parenExpr
    suffix <- P.optional (P.try suffixOp)
    (case suffix of
            Just op -> calcExpr' (Just (CalcSuffix v op))
            Nothing -> pure v
        )
        <* P.space

prefixExpr :: Parser CalcExpr
prefixExpr =
    CalcPrefix <$> prefixOp <*> (P.try valExpr <|> parenExpr) <* P.space

single :: Parser CalcExpr
single = (P.try valExpr <|> P.try prefixExpr <|> parenExpr) <* P.space

constant :: Parser Double
constant =
    P.choice [P.char 'e' $> exp 1, P.try $ P.string "pi" $> pi]
        <*  P.space
        <?> "constant"

value :: Parser CalcExpr
value =
    CalcVal <$> (constant <|> ((P.try num <|> int) <?> "number")) <* P.space

parenExpr :: Parser CalcExpr
parenExpr =
    P.between (P.char '(') (P.char ')') (P.space *> calcExpr' Nothing)
        <*  P.space
        <?> "parenthesized expression"

binaryExpr :: CalcExpr -> Parser CalcExpr
binaryExpr lhs = do
    op <- binaryOp
    let p = precedence op
    rhs    <- single
    nextOp <- P.lookAhead (P.optional binaryOp)
    let nextPrecIsHigher = maybe False (\nop -> precedence nop > p) nextOp
    (if nextPrecIsHigher
            then CalcBinary lhs op <$> calcExpr' (Just rhs)
            else calcExpr' (Just (CalcBinary lhs op rhs))
        )
        <* P.space

binaryOp :: Parser BinaryOp
binaryOp =
    P.choice
            (map
                P.try
                [ P.char '+' $> Plus
                , P.char '-' $> Minus
                , P.char '*' $> Times
                , P.char '/' $> Divide
                , P.string "mod" $> Mod
                , P.char '^' $> Exponent
                ]
            )
        <*  P.space
        <?> "operator"

prefixOp :: Parser PrefixOp
prefixOp =
    P.choice
            (map
                P.try
                [ P.string "sqrt" $> Sqrt
                , P.string "cbrt" $> Cbrt
                , P.string "log" $> Log
                , P.string "ln" $> Ln
                , P.string "sinh" $> Sinh
                , P.string "cosh" $> Cosh
                , P.string "tanh" $> Tanh
                , P.string "sin" $> Sin
                , P.string "cos" $> Cos
                , P.string "tan" $> Tan
                , P.string "abs" $> Abs
                , P.string "round" $> Round
                , P.string "floor" $> Floor
                , P.string "ceil" $> Ceil
                , P.string "degrees" $> Degrees
                , P.string "radians" $> Radians
                , P.char '-' $> Neg
                , P.string "fact" $> Fact
                , P.string "randf" $> RandFloat
                , P.string "randi" $> RandInt
                , P.string "rand" $> Rand
                ]
            )
        <*  P.try (P.space1 <|> P.lookAhead (P.char '(' $> ()))
        <*  P.space
        <?> "function"

suffixOp :: Parser SuffixOp
suffixOp =
    P.choice
            (map
                P.try
                [ P.char '%' $> Percent
                , P.char '!' $> Factorial
                , P.string "!!" $> Factorial
                ]
            )
        <*  P.space
        <?> "suffix"

reduceExpr :: CalcExpr -> IO Double
reduceExpr (CalcVal v              ) = pure v

reduceExpr (CalcBinary e1 Plus   e2) = (+) <$> reduceExpr e1 <*> reduceExpr e2
reduceExpr (CalcBinary e1 Minus  e2) = (-) <$> reduceExpr e1 <*> reduceExpr e2
reduceExpr (CalcBinary e1 Times  e2) = (*) <$> reduceExpr e1 <*> reduceExpr e2
reduceExpr (CalcBinary e1 Divide e2) = (/) <$> reduceExpr e1 <*> reduceExpr e2
reduceExpr (CalcBinary e1 Exponent e2) =
    (**) <$> reduceExpr e1 <*> reduceExpr e2
reduceExpr (CalcBinary e1 Mod e2) = mod' <$> reduceExpr e1 <*> reduceExpr e2

reduceExpr (CalcPrefix Sqrt e   ) = sqrt <$> reduceExpr e
reduceExpr (CalcPrefix Cbrt e   ) = (**) <$> reduceExpr e <*> pure (1 / 3)
reduceExpr (CalcPrefix Log  e   ) = logBase 10 <$> reduceExpr e
reduceExpr (CalcPrefix Ln   e   ) = log <$> reduceExpr e
reduceExpr (CalcPrefix Sin  e   ) = sin <$> reduceExpr e
reduceExpr (CalcPrefix Cos  e   ) = cos <$> reduceExpr e
reduceExpr (CalcPrefix Tan  e   ) = tan <$> reduceExpr e
reduceExpr (CalcPrefix Sinh e   ) = sinh <$> reduceExpr e
reduceExpr (CalcPrefix Cosh e   ) = cosh <$> reduceExpr e
reduceExpr (CalcPrefix Tanh e   ) = tanh <$> reduceExpr e
reduceExpr (CalcPrefix Abs  e   ) = abs <$> reduceExpr e
reduceExpr (CalcPrefix Round e) =
    fromIntegral . (round :: Double -> Integer) <$> reduceExpr e
reduceExpr (CalcPrefix Floor e) =
    fromIntegral . (floor :: Double -> Integer) <$> reduceExpr e
reduceExpr (CalcPrefix Ceil e) =
    fromIntegral . (ceiling :: Double -> Integer) <$> reduceExpr e
reduceExpr (CalcPrefix Degrees e) = do
    v <- reduceExpr e
    pure $ v * 180 / pi
reduceExpr (CalcPrefix Radians e) = do
    v <- reduceExpr e
    pure $ v * pi / 180
reduceExpr (CalcPrefix Neg       e) = negate <$> reduceExpr e
reduceExpr (CalcPrefix Fact      e) = factorial <$> reduceExpr e
reduceExpr (CalcPrefix RandFloat e) = randf =<< reduceExpr e
reduceExpr (CalcPrefix RandInt   e) = randi =<< reduceExpr e
reduceExpr (CalcPrefix Rand      e) = do
    n <- reduceExpr e
    if n == fromIntegral (round n :: Integer) then randi n else randf n

reduceExpr (CalcSuffix e Percent        ) = reduceExpr e <&> (* 0.01)
reduceExpr (CalcSuffix e Factorial      ) = factorial <$> reduceExpr e
reduceExpr (CalcSuffix e DoubleFactorial) = doubleFactorial <$> reduceExpr e

factorial :: Double -> Double
factorial n = gamma $ n + 1

randf :: Double -> IO Double
randf n = randomRIO (0, n)

randi :: Double -> IO Double
randi n = fromIntegral <$> randomRIO (0, round n :: Integer)

doubleFactorial :: Double -> Double
doubleFactorial n =
    let k = n / 2
    in  factorial k * 2 ** k * (pi / 2) ** (1 / 4 * (-1 + cos (n * pi)))

eval :: CalcExpr -> IO Double
eval = reduceExpr

--- File: ./src/Commands.hs ---
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RankNTypes #-}

module Commands
    ( ArgParser
    , Parser
    , parseArgs
    , arg
    , optArg
    , restArg
    , optRestArg
    , multiArg
    , optMultiArg
    , int
    , num
    , str
    , defaultArgErrorText
    , defaultParseErrorText
    , defaultHelpText
    , handleCommand
    , customRestArg
    ) where

import           Control.Monad                  ( filterM )
import           Data.Char                      ( isSpace )
import           Data.Foldable                  ( find )
import           Data.Functor                   ( ($>) )
import           Data.Maybe
import           Data.String                    ( IsString )
import           Data.Text                      ( Text )
import qualified Data.Text                     as T
import           Data.Void                      ( Void )
import qualified Discord                       as D
import qualified Discord.Internal.Types        as D
import           DiscordHelper                  ( isCommand
                                                , replyTo
                                                )
import qualified Text.Megaparsec               as P
import           Text.Megaparsec                ( (<?>)
                                                , ParseErrorBundle
                                                , Parsec
                                                )
import qualified Text.Megaparsec.Char          as P
import qualified Text.Megaparsec.Char.Lexer    as PL

type Parser = Parsec Void Text

data ArgArity = Single | Multi
data ArgReq = Required | Optional
type ArgType = (ArgReq, ArgArity)
data Arg = Arg
    { argType        :: ArgType
    , argName        :: Text
    , argDescription :: Text
    }
data ArgParser a = ArgParser
    { argParserArgs :: [Arg]
    , argParser     :: Parser a
    }
    deriving Functor
type CommandArgInfo = [Arg]

instance Applicative ArgParser where
    pure a = ArgParser [] (pure a)
    ArgParser { argParserArgs = args1, argParser = p1 } <*> ArgParser { argParserArgs = args2, argParser = p2 }
        = ArgParser { argParserArgs = args1 <> args2, argParser = p1 <*> p2 }

type CommandName = Text
type HelpText = Text

arg :: Text -> Text -> Parser a -> ArgParser a
arg name desc p = ArgParser
    [ Arg { argType        = (Required, Single)
          , argName        = name
          , argDescription = desc
          }
    ]
    (P.space *> p)

optArg :: Text -> Text -> Parser a -> ArgParser (Maybe a)
optArg name desc p = ArgParser
    [ Arg { argType        = (Optional, Single)
          , argName        = name
          , argDescription = desc
          }
    ]
    (P.space *> P.optional p)

restArg :: Text -> Text -> ArgParser Text
restArg name desc = ArgParser
    [Arg { argType = (Required, Multi), argName = name, argDescription = desc }]
    (P.space *> restStr1)

optRestArg :: Text -> Text -> ArgParser (Maybe Text)
optRestArg name desc = ArgParser
    [Arg { argType = (Optional, Multi), argName = name, argDescription = desc }]
    (P.space *> P.optional restStr1)

customRestArg :: Text -> Text -> Parser a -> ArgParser a
customRestArg name desc p = ArgParser
    [Arg { argType = (Required, Multi), argName = name, argDescription = desc }]
    (P.space *> p)

multiArg :: Text -> Text -> Parser a -> ArgParser [a]
multiArg name desc p = ArgParser
    [Arg { argType = (Required, Multi), argName = name, argDescription = desc }]
    (P.space *> manyArgs1 p)

optMultiArg :: Text -> Text -> Parser a -> ArgParser (Maybe [a])
optMultiArg name desc p = ArgParser
    [Arg { argType = (Optional, Multi), argName = name, argDescription = desc }]
    (P.space *> P.optional (manyArgs1 p))

restStr1 :: Parser Text
restStr1 = T.pack <$> (P.space *> P.some P.anySingle)

possiblyNegative :: Num a => Parser a -> String -> Parser a
possiblyNegative p label =
    P.space *> (P.option id (P.char '-' $> negate) <*> (p <?> label) <?> label)

int :: Num a => Parser a
int = possiblyNegative PL.decimal "integer"

num :: RealFloat a => Parser a
num = possiblyNegative PL.float "num"

str :: Parser Text
str = T.pack <$> (P.space *> P.some (P.satisfy (not . isSpace))) <?> "string"

manyArgs1 :: Parser a -> Parser [a]
manyArgs1 p = P.some (P.space *> p)

parseArgs
    :: Text
    -> (command -> CommandName)
    -> (command -> ArgParser a)
    -> command
    -> Text
    -> Either (ParseErrorBundle Text Void) a
parseArgs prefix commandName commandArgs command = P.parse
    (  P.string prefix
    *> P.string (commandName command)
    *> argParser (commandArgs command)
    <* P.eof
    )
    ""

showUsage :: Text -> Text -> ArgParser a -> Text
showUsage prefix name args =
    "Usage: " <> prefix <> name <> argStr (argParserArgs args)

defaultHelpText
    :: Text
    -> (command -> CommandName)
    -> (command -> HelpText)
    -> (command -> ArgParser a)
    -> Maybe Text
    -> [command]
    -> Text
defaultHelpText prefix commandName commandHelpText commandArgs mcommand commands
    = case mcommand of
        Just commandStr ->
            case find ((== commandStr) . commandName) commands of
                Nothing -> "Command not found: **" <> commandStr <> "**"
                Just command ->
                    let name = commandName command
                        args = commandArgs command
                    in  "```\n"
                            <> commandStr
                            <> " help\n-----------------------------\n"
                            <> commandHelpText command
                            <> "\n\n"
                            <> showUsage prefix name args
                            <> case argParserArgs args of
                                   [] -> ""
                                   argInfo ->
                                       "\n\n"
                                           <> (T.intercalate "\n" . map
                                                  (\Arg { argName, argDescription } ->
                                                      let arg' = T.toUpper
                                                              argName
                                                      in  " "
                                                              <> arg'
                                                              <> " - "
                                                              <> argDescription
                                                  )
                                              )
                                                  argInfo
                            <> "\n```"
        Nothing ->
            "```\nCommands (prefix with "
                <> prefix
                <> ")\n-----------------------------\n"
                <> T.intercalate
                       "\n"
                       (map
                           (\command ->
                               commandName command
                                   <> argStr
                                          (argParserArgs $ commandArgs command)
                                   <> " - "
                                   <> commandHelpText command
                           )
                           commands
                       )
                <> "\n```"

argStr :: CommandArgInfo -> Text
argStr argInfoArgs = mconcat $ map
    (\Arg { argType, argName } -> " " <> modifyArg argType (T.toUpper argName))
    argInfoArgs

modifyArg :: (Semigroup a, IsString a) => (ArgReq, ArgArity) -> a -> a
modifyArg (r, s) arg0 =
    let arg1 = case s of
            Single -> arg0
            Multi  -> arg0 <> "..."
    in  case r of
            Required -> arg1
            Optional -> "[" <> arg1 <> "]"

type ErrorHandler command a
    =  Text
    -> (command -> CommandName)
    -> (command -> ArgParser a)
    -> command
    -> Text
    -> ParseErrorBundle Text Void
    -> Text

defaultParseErrorText :: Text -> ParseErrorBundle Text Void -> Text
defaultParseErrorText message e =
    message <> "\n\n" <> T.pack (P.errorBundlePretty e)

defaultArgErrorText :: ErrorHandler command a
defaultArgErrorText prefix commandName commandArgs command message e =
    "```\nInvalid args:\n\n"
        <> defaultParseErrorText message e
        <> "\n"
        <> showUsage prefix (commandName command) (commandArgs command)
        <> "\n```"

handleCommand
    :: Text
    -> (command -> Text)
    -> (command -> ArgParser a)
    -> (a -> D.Message -> D.DiscordHandler ())
    -> Maybe (ErrorHandler command a)
    -> D.Message
    -> [command]
    -> D.DiscordHandler Bool
handleCommand prefix commandName commandArgs commandHandler errorHandler message commands
    = do
        commandMatches <- filterM
            (\command -> isCommand prefix (commandName command) message)
            commands
        case commandMatches of
            (command : _) -> do
                case
                        parseArgs prefix
                                  commandName
                                  commandArgs
                                  command
                                  (D.messageText message)
                    of
                        Left e -> replyTo message $ fromMaybe
                            defaultArgErrorText
                            errorHandler
                            prefix
                            commandName
                            commandArgs
                            command
                            (D.messageText message)
                            e
                        Right cas -> commandHandler cas message
                pure True
            _ -> pure False


--- File: ./src/DiscordHelper.hs ---
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}

module DiscordHelper
    ( isCommand
    , writeError
    , writeLog
    , restCall
    , replyTo
    , createGuildBan
    , createMessage
    , isFromSelf
    , isFromUser
    , isFromBot
    , messageStartsWith
    , messageEquals
    , messageContains
    , updateStatus
    , Predicate
    , (|||)
    , (&&&)
    ) where

import           Control.Concurrent             ( writeChan )
import           Control.Monad.Reader           ( ask
                                                , liftIO
                                                )
import           Data.Aeson                     ( FromJSON )
import           Data.Foldable                  ( for_ )
import           Data.Text                      ( Text )
import qualified Data.Text                     as T
import qualified Discord                       as D
import qualified Discord.Handle                as D
import qualified Discord.Internal.Rest         as D
import qualified Discord.Requests              as D

updateStatus :: D.ActivityType -> Maybe Text -> D.DiscordHandler ()
updateStatus activityType mactivity =
    D.sendCommand $ D.UpdateStatus $ D.UpdateStatusOpts
        { D.updateStatusOptsSince     = Nothing
        , D.updateStatusOptsGame      = case mactivity of
            Just activity -> Just $ D.Activity activity activityType Nothing
            Nothing       -> Nothing
        , D.updateStatusOptsNewStatus = D.UpdateStatusOnline
        , D.updateStatusOptsAFK       = False
        }

type Predicate = D.Message -> D.DiscordHandler Bool

infixl 2 |||
(|||) :: Predicate -> Predicate -> Predicate
(pred1 ||| pred2) message = do
    p1 <- pred1 message
    p2 <- pred2 message
    pure $ p1 || p2

infixl 3 &&&
(&&&) :: Predicate -> Predicate -> Predicate
(pred1 &&& pred2) message = do
    p1 <- pred1 message
    p2 <- pred2 message
    pure $ p1 && p2

isFromSelf :: Predicate
isFromSelf message = do
    cache <- D.readCache
    pure $ D.userId (D.cacheCurrentUser cache) == D.userId
        (D.messageAuthor message)

isFromUser :: D.UserId -> Predicate
isFromUser userId message = pure $ D.userId (D.messageAuthor message) == userId

isFromBot :: Predicate
isFromBot m = pure $ D.userIsBot (D.messageAuthor m)

isCommand :: Text -> Text -> Predicate
isCommand prefix command message = do
    fromBot <- isFromBot message
    if fromBot
        then pure False
        else do
            (   messageEquals (prefix <> command)
                ||| messageStartsWith (prefix <> command <> " ")
                )
                message

messageStartsWith :: Text -> Predicate
messageStartsWith text =
    pure . (text `T.isPrefixOf`) . T.toLower . D.messageText

messageEquals :: Text -> Predicate
messageEquals text = pure . (text ==) . T.toLower . D.messageText

messageContains :: Text -> Predicate
messageContains text = pure . (text `T.isInfixOf`) . T.toLower . D.messageText

writeLog :: Text -> D.DiscordHandler ()
writeLog l = do
    h <- ask
    liftIO $ writeChan (D.discordHandleLog h) l

writeError :: Text -> D.DiscordHandler ()
writeError e = do
    h <- ask
    liftIO $ writeChan (D.discordHandleLog h) $ "Error: " <> e

restCall :: (FromJSON a, D.Request (r a)) => r a -> D.DiscordHandler ()
restCall request = do
    r <- D.restCall request
    case r of
        Right _   -> pure ()
        Left  err -> writeError $ T.pack $ show err

replyTo :: D.Message -> Text -> D.DiscordHandler ()
replyTo replyingTo =
    createMessage (D.messageChannel replyingTo) (Just $ D.messageId replyingTo)

createMessage
    :: D.ChannelId -> Maybe D.MessageId -> Text -> D.DiscordHandler ()
createMessage channelId replyingToId message =
    let chunks = T.chunksOf 2000 message
    in
        for_ chunks $ \chunk -> restCall $ D.CreateMessageDetailed
            channelId
            D.def
                { D.messageDetailedContent         = chunk
                , D.messageDetailedAllowedMentions = Just D.def
                    { D.mentionRepliedUser = False
                    }
                , D.messageDetailedReference       = fmap
                    (\mId -> D.def { D.referenceMessageId = Just mId })
                    replyingToId
                }

createGuildBan :: D.GuildId -> D.UserId -> Text -> D.DiscordHandler ()
createGuildBan guildId userId banMessage = restCall $ D.CreateGuildBan
    guildId
    userId
    (D.CreateGuildBanOpts Nothing (Just banMessage))

--- File: ./src/Lib.hs ---
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}

module Lib
    ( goodbot
    ) where

import           Calculator                     ( CalcExpr
                                                , calcExpr
                                                , eval
                                                )
import           Commands                       ( ArgParser
                                                , customRestArg
                                                , defaultHelpText
                                                , handleCommand
                                                , int
                                                , optArg
                                                , optRestArg
                                                , restArg
                                                , str
                                                )
import           Control.Concurrent.STM         ( TVar
                                                , atomically
                                                , modifyTVar'
                                                , newTVarIO
                                                , readTVar
                                                , readTVarIO
                                                )
import           Control.Lens                   ( (&)
                                                , (.~)
                                                , view
                                                )
import           Control.Monad                  ( filterM
                                                , unless
                                                , when
                                                )
import           Control.Monad.Catch            ( catchAll
                                                , catchIOError
                                                )
import           Control.Monad.Reader           ( ReaderT
                                                , ask
                                                , asks
                                                , lift
                                                , liftIO
                                                , runReaderT
                                                )
import           Data.Aeson                     ( (.:)
                                                , FromJSON
                                                , defaultOptions
                                                , eitherDecode
                                                , fieldLabelModifier
                                                , genericParseJSON
                                                , parseJSON
                                                , withObject
                                                )
import qualified Data.ByteString.Lazy          as BSL
import           Data.Char                      ( toLower )
import           Data.List                      ( delete
                                                , nub
                                                , stripPrefix
                                                )
import           Data.Maybe                     ( fromMaybe )
import           Data.Text                      ( Text
                                                , intercalate
                                                )
import qualified Data.Text                     as T
import qualified Data.Text.Encoding            as T
import qualified Data.Text.IO                  as T
import           Data.Time                      ( defaultTimeLocale
                                                , formatTime
                                                , getCurrentTime
                                                , getCurrentTimeZone
                                                , utcToLocalTime
                                                )
import           Data.Yaml                      ( decodeFileEither )
import qualified Discord                       as D
import qualified Discord.Internal.Rest         as D
import           DiscordHelper                  ( Predicate
                                                , createGuildBan
                                                , createMessage
                                                , isFromSelf
                                                , isFromUser
                                                , messageContains
                                                , replyTo
                                                , updateStatus
                                                , writeError
                                                , writeLog
                                                , (|||)
                                                )
import           GHC.Generics                   ( Generic )
import           Network.Wreq                   ( Response
                                                , defaults
                                                , get
                                                , getWith
                                                , header
                                                , param
                                                , responseBody
                                                )
import qualified Network.Wreq                  as W
import           System.Environment             ( getArgs )
import           System.Random                  ( randomIO )
import           Text.Read                      ( readMaybe )

type App a = ReaderT Config D.DiscordHandler a

data Db = Db
    { dbResponses :: [Text]
    , dbActivity  :: Maybe (D.ActivityType, Text)
    , dbMeanness  :: Int
    }
    deriving (Show, Read)

defaultDb :: Db
defaultDb = Db { dbResponses = ["hi"], dbActivity = Nothing, dbMeanness = 5 }

data Config = Config
    { configDictKey       :: Maybe Text
    , configUrbanKey      :: Maybe Text
    , configCommandPrefix :: Text
    , configDb            :: TVar Db
    , configDbFile        :: FilePath
    }

data UserConfig = UserConfig
    { userConfigDiscordToken  :: Text
    , userConfigDictKey       :: Maybe Text
    , userConfigUrbanKey      :: Maybe Text
    , userConfigCommandPrefix :: Maybe Text
    , userConfigDbFile        :: Maybe FilePath
    }
    deriving (Generic, Show)

instance FromJSON UserConfig where
    parseJSON = genericParseJSON defaultOptions
        { fieldLabelModifier = stripJSONPrefix "userConfig"
        }

stripJSONPrefix :: String -> String -> String
stripJSONPrefix prefix s = case stripPrefix prefix s of
    Just (c : rest) -> toLower c : rest
    _               -> s

defaultConfigFile :: FilePath
defaultConfigFile = "config.yaml"

defaultDbFile :: FilePath
defaultDbFile = "db"

logText :: Text -> IO ()
logText t = do
    now <- getCurrentTime
    tz  <- getCurrentTimeZone
    T.putStrLn
        $  T.pack (formatTime defaultTimeLocale "%F %T" $ utcToLocalTime tz now)
        <> ": "
        <> t

goodbot :: IO ()
goodbot = do
    args <- getArgs
    let configFile = case args of
            []     -> defaultConfigFile
            [path] -> path
            _      -> error "too many arguments provided: expected at most 1"
    config@UserConfig {..} <- either (error . show) id
        <$> decodeFileEither configFile
    dbStr <- (Just <$> readFile (fromMaybe defaultDbFile userConfigDbFile))
        `catchIOError` \_ -> pure Nothing
    let db = fromMaybe defaultDb $ dbStr >>= readMaybe
    dbRef           <- newTVarIO db
    userFacingError <-
        D.runDiscord
                (D.def { D.discordToken   = userConfigDiscordToken
                       , D.discordOnStart = onStart config
                       , D.discordOnEvent = eventHandler config dbRef
                       , D.discordOnLog   = logText
                       }
                )
            `catchAll` \e -> pure $ T.pack $ show e
    T.putStrLn userFacingError

onStart :: UserConfig -> D.DiscordHandler ()
onStart config = do
    writeLog $ "bot started with config " <> T.pack (show config)

eventHandler :: UserConfig -> TVar Db -> D.Event -> D.DiscordHandler ()
eventHandler UserConfig {..} dbRef event =
    let config = Config
            { configDictKey       = userConfigDictKey
            , configUrbanKey      = userConfigUrbanKey
            , configCommandPrefix = fromMaybe "!" userConfigCommandPrefix
            , configDb            = dbRef
            , configDbFile        = fromMaybe defaultDbFile userConfigDbFile
            }
    in  flip runReaderT config $ case event of
            D.Ready{}                  -> ready dbRef
            D.MessageCreate message    -> messageCreate message
            D.TypingStart   typingInfo -> typingStart typingInfo
            _                          -> pure ()

ready :: TVar Db -> App ()
ready dbRef = do
    Db { dbActivity = mactivity } <- liftIO $ readTVarIO dbRef
    case mactivity of
        Just (activityType, activity) ->
            lift $ updateStatus activityType $ Just activity
        Nothing -> pure ()

type CommandFunc = D.Message -> App ()

data Command
    = Define
    | Urban
    | Add
    | Remove
    | List
    | Playing
    | ListeningTo
    | CompetingIn
    | Meanness
    | Calc
    | RR
    | Help
    deriving (Show, Eq, Enum, Bounded)

data CommandArgs
    = RRArgs
    | DefineArgs Text
    | UrbanArgs Text
    | AddArgs Text
    | RemoveArgs Text
    | ListArgs
    | PlayingArgs (Maybe Text)
    | ListeningToArgs (Maybe Text)
    | CompetingInArgs (Maybe Text)
    | MeannessArgs (Maybe Int)
    | CalcArgs CalcExpr
    | HelpArgs (Maybe Text)
    deriving (Show, Eq)

commandName :: Command -> Text
commandName = T.toLower . T.pack . head . words . show

commandArgs :: Command -> ArgParser CommandArgs
commandArgs RR = pure RRArgs
commandArgs Define =
    DefineArgs <$> restArg "term" "The word or phrase to look up."
commandArgs Urban =
    UrbanArgs <$> restArg "term" "The word or phrase to look up."
commandArgs Add = AddArgs <$> restArg "response" "The response to add."
commandArgs Remove =
    RemoveArgs <$> restArg "response" "The response to remove."
commandArgs List = pure ListArgs
commandArgs Playing =
    PlayingArgs <$> optRestArg "name" "What's the bot playing?"
commandArgs ListeningTo =
    ListeningToArgs <$> optRestArg "name" "What's the bot listening to?"
commandArgs CompetingIn =
    CompetingInArgs <$> optRestArg "name" "What's the bot competing in?"
commandArgs Meanness =
    MeannessArgs
        <$> optArg
                "level"
                "The number between 0 and 10 to set the bot's meanness to. Higher is meaner. Leave blank to view current meanness."
                int
commandArgs Calc =
    CalcArgs
        <$> customRestArg "input"
                          "Expression for calculator to evaluate."
                          calcExpr
commandArgs Help =
    HelpArgs <$> optArg "command" "Command to show help for." str

commandHelpText :: Command -> Text
commandHelpText RR = "Play Russian Roulette!"
commandHelpText Define =
    "Look up the definition of a word or phrase, using Urban Dictionary as a backup."
commandHelpText Urban =
    "Look up the definition of a word or phrase on Urban Dictionary."
commandHelpText Add =
    "Add a response to be randomly selected when the bot replies after being pinged."
commandHelpText Remove      = "Remove a response from the bot's response pool."
commandHelpText List        = "List all responses in the response pool."
commandHelpText Playing     = "Set bot's activity to Playing."
commandHelpText ListeningTo = "Set bot's activity to Listening To."
commandHelpText CompetingIn = "Set bot's activity to Competing In."
commandHelpText Meanness
    = "Set bot's meanness from 0-10 or display current meanness if no argument given."
commandHelpText Calc = "A basic calculator."
commandHelpText Help =
    "Show this help or show detailed help for a given command."

commandFunc :: CommandArgs -> CommandFunc
commandFunc RRArgs                = russianRoulette
commandFunc (DefineArgs term    ) = define getDefineOutput term
commandFunc (UrbanArgs  term    ) = define getUrbanOutput term
commandFunc (AddArgs    response) = addResponse response
commandFunc (RemoveArgs response) = removeResponse response
commandFunc ListArgs              = listResponses
commandFunc (PlayingArgs status)  = setActivity D.ActivityTypeGame status
commandFunc (ListeningToArgs status) =
    setActivity D.ActivityTypeListening status
commandFunc (CompetingInArgs status) =
    setActivity D.ActivityTypeCompeting status
commandFunc (MeannessArgs meanness) = setMeanness meanness
commandFunc (CalcArgs     expr    ) = calc expr
commandFunc (HelpArgs     command ) = showHelp command

commands :: [Command]
commands = [minBound .. maxBound]

isFromCarl :: Predicate
isFromCarl = isFromUser 235148962103951360

predicates :: [(Predicate, CommandFunc)]
predicates =
    [ (isFromCarl, simpleReply "Carl is a cuck")
    , ( mentionsMe ||| messageContains "@everyone" ||| messageContains "@here"
      , respond
      )
    ]

messageCreate :: D.Message -> App ()
messageCreate message = do
    self <- lift $ isFromSelf message
    if self
        then pure ()
        else do
            prefix         <- asks configCommandPrefix
            config         <- ask
            commandHandled <- lift $ handleCommand
                prefix
                commandName
                commandArgs
                (\args m -> flip runReaderT config $ commandFunc args m)
                Nothing
                message
                commands
            unless commandHandled $ do
                predicateMatches <- lift
                    $ filterM (\(p, _) -> p message) predicates
                case predicateMatches of
                    ((_, c) : _) -> c message
                    _            -> pure ()

typingStart :: D.TypingInfo -> App ()
typingStart (D.TypingInfo userId channelId _utcTime) = do
    db       <- asks configDb
    meanness <- liftIO $ dbMeanness <$> readTVarIO db
    when (meanness > 0) $ do
        shouldReply <-
            liftIO
            $   (== 0)
            .   (`mod` meannessRatio meanness)
            <$> (randomIO :: IO Int)
        when shouldReply
            .  lift
            .  createMessage channelId Nothing
            .  T.pack
            $  "shut up <@"
            <> show userId
            <> ">"
  where
    meannessRatio 11 = 1
    meannessRatio n  = 2000 `div` n

russianRoulette :: CommandFunc
russianRoulette message = do
    chamber <- liftIO $ (`mod` 6) <$> (randomIO :: IO Int)
    lift $ case (chamber, D.messageGuild message) of
        (0, Just gId) -> do
            replyTo message response
            createGuildBan gId (D.userId $ D.messageAuthor message) response
            where response = "Bang!"
        _ -> replyTo message "Click."

data Definition = Definition
    { defPartOfSpeech :: Maybe Text
    , defDefinitions  :: [Text]
    }
    deriving Show

instance FromJSON Definition where
    parseJSON = withObject "Definition" $ \v -> do
        partOfSpeech <- v .: "fl"
        definitions  <- v .: "shortdef"
        pure Definition { defPartOfSpeech = partOfSpeech
                        , defDefinitions  = definitions
                        }

define :: (Text -> App (Maybe Text)) -> Text -> CommandFunc
define getOutput phrase message = do
    moutput <- getOutput phrase
    lift . replyTo message $ case moutput of
        Just output -> output
        Nothing     -> "No definition found for **" <> phrase <> "**"

buildDefineOutput :: Text -> Definition -> Text
buildDefineOutput word definition =
    let definitions = case defDefinitions definition of
            [def] -> def
            defs  -> T.intercalate "\n\n" $ zipWith
                (\i def -> T.pack (show i) <> ". " <> def)
                [1 :: Int ..]
                defs
    in  "**"
            <> word
            <> "**"
            <> (case defPartOfSpeech definition of
                   Just partOfSpeech -> " *" <> partOfSpeech <> "*"
                   Nothing           -> ""
               )
            <> "\n"
            <> definitions

getDefineOutput :: Text -> App (Maybe Text)
getDefineOutput word = do
    response <- getDictionaryResponse word
    buildDefineOutputHandleFail
            word
            (response >>= eitherDecode . view responseBody)
        $ Just
        $ getUrbanOutput word

getUrbanOutput :: Text -> App (Maybe Text)
getUrbanOutput word = do
    urbanResponse <- getUrbanResponse word
    buildDefineOutputHandleFail
        word
        (urbanResponse >>= decodeUrban . view responseBody)
        Nothing

buildDefineOutputHandleFail
    :: Text
    -> Either String [Definition]
    -> Maybe (App (Maybe Text))
    -> App (Maybe Text)
buildDefineOutputHandleFail word (Right defs) _ | not (null defs) =
    pure $ Just $ T.intercalate "\n\n" $ map (buildDefineOutput word) defs
buildDefineOutputHandleFail _ (Left err) Nothing =
    lift (writeError $ T.pack err) >> pure Nothing
buildDefineOutputHandleFail _ (Left err) (Just fallback) =
    lift (writeError $ T.pack err) >> fallback
buildDefineOutputHandleFail _ _         (Just fallback) = fallback
buildDefineOutputHandleFail _ (Right _) Nothing         = pure Nothing

getDictionaryResponse :: Text -> App (Either String (Response BSL.ByteString))
getDictionaryResponse word = do
    mapiKey <- asks configDictKey
    case mapiKey of
        Nothing -> pure $ Left "no dictionary.com api key set"
        Just apiKey ->
            liftIO
                $   fmap Right
                <$> get
                $   T.unpack
                $ "https://dictionaryapi.com/api/v3/references/collegiate/json/"
                <>  word
                <>  "?key="
                <>  apiKey

getUrbanResponse :: Text -> App (Either String (Response BSL.ByteString))
getUrbanResponse word = do
    mapiKey <- asks configUrbanKey
    case mapiKey of
        Nothing     -> pure $ Left "no urban dictionary api key set"
        Just apiKey -> liftIO $ Right <$> getWith
            (urbanOpts apiKey word)
            "https://mashape-community-urban-dictionary.p.rapidapi.com/define"

urbanOpts :: Text -> Text -> W.Options
urbanOpts apiKey term =
    defaults
        &  header "x-rapidapi-key"
        .~ [T.encodeUtf8 apiKey]
        &  header "x-rapidapi-host"
        .~ ["mashape-community-urban-dictionary.p.rapidapi.com"]
        &  header "useQueryString"
        .~ ["true"]
        &  param "term"
        .~ [term]

newtype UrbanDefinition = UrbanDefinition {urbanDefDefinition :: [Text]}
    deriving (Show)

instance FromJSON UrbanDefinition where
    parseJSON = withObject "UrbanDefinition" $ \v -> do
        list <- v .: "list"
        defs <- traverse (.: "definition") list
        pure UrbanDefinition { urbanDefDefinition = defs }

decodeUrban :: BSL.ByteString -> Either String [Definition]
decodeUrban = fmap urbanToDictionary . eitherDecode

urbanToDictionary :: UrbanDefinition -> [Definition]
urbanToDictionary (UrbanDefinition def) =
    [ Definition Nothing def | not (null def) ]

mentionsMe :: Predicate
mentionsMe message = do
    cache <- D.readCache
    pure $ D.userId (D.cacheCurrentUser cache) `elem` map
        D.userId
        (D.messageMentions message)

respond :: CommandFunc
respond message = do
    responses   <- getResponses
    responseNum <- liftIO $ (`mod` length responses) <$> (randomIO :: IO Int)
    lift $ replyTo message $ responses !! responseNum

showHelp :: Maybe Text -> CommandFunc
showHelp mcommand message = do
    prefix <- asks configCommandPrefix
    lift . replyTo message $ defaultHelpText prefix
                                             commandName
                                             commandHelpText
                                             commandArgs
                                             mcommand
                                             commands

simpleReply :: Text -> CommandFunc
simpleReply replyText message = lift $ replyTo message replyText

addResponse :: Text -> CommandFunc
addResponse response message = do
    updateDb (\d -> d { dbResponses = nub $ response : dbResponses d })
    lift . replyTo message $ "Added **" <> response <> "** to responses"

getResponses :: App [Text]
getResponses = do
    dbRef <- asks configDb
    liftIO $ dbResponses <$> readTVarIO dbRef

removeResponse :: Text -> CommandFunc
removeResponse response message = do
    oldResponses <- getResponses
    if response `elem` oldResponses
        then do
            updateDb (\d -> d { dbResponses = delete response $ dbResponses d })
            lift
                .  replyTo message
                $  "Removed **"
                <> response
                <> "** from responses"
        else
            lift . replyTo message $ "Response **" <> response <> "** not found"

listResponses :: CommandFunc
listResponses message = do
    responses <- intercalate "\n" <$> getResponses
    lift $ replyTo message responses

setActivity :: D.ActivityType -> Maybe Text -> CommandFunc

setActivity activityType Nothing message = do
    lift $ updateStatus activityType Nothing
    updateDb (\d -> d { dbActivity = Nothing })
    lift $ replyTo message "Removed status"

setActivity activityType (Just status) message = do
    lift $ updateStatus activityType $ Just status
    updateDb (\d -> d { dbActivity = Just (activityType, status) })
    lift
        $  replyTo message
        $  "Updated status to **"
        <> activityTypeText
        <> " "
        <> status
        <> "**"
  where
    activityTypeText = case activityType of
        D.ActivityTypeGame      -> "Playing"
        D.ActivityTypeListening -> "Listening to"
        D.ActivityTypeStreaming -> "Streaming"
        D.ActivityTypeCompeting -> "Competing in"

setMeanness :: Maybe Int -> CommandFunc

setMeanness (Just m) message = do
    let meanness = min 11 . max 0 $ m
    updateDb (\d -> d { dbMeanness = meanness })
    lift
        .  replyTo message
        $  "Set meanness to **"
        <> T.pack (show meanness)
        <> "**"

setMeanness Nothing message = do
    dbRef    <- asks configDb
    meanness <- liftIO $ dbMeanness <$> readTVarIO dbRef
    lift
        .  replyTo message
        $  "Current meanness is **"
        <> T.pack (show meanness)
        <> "**"

calc :: CalcExpr -> CommandFunc
calc expr message = do
    result <- liftIO $ eval expr
    lift . replyTo message . T.pack . show $ result

updateDb :: (Db -> Db) -> App ()
updateDb f = do
    dbRef      <- asks configDb
    dbFileName <- asks configDbFile
    db         <- liftIO $ atomically $ do
        modifyTVar' dbRef f
        readTVar dbRef
    liftIO $ writeFile dbFileName $ show db

